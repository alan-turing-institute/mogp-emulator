.. _ProcBuildCoreBLEmpirical:

Procedure: Empirical construction of a Bayes linear emulator for the core problem using only simulator runs
===========================================================================================================

Description and Background
--------------------------

Ordinarily, when constructing :ref:`Bayes linear
emulators<ThreadCoreBL>` we rely on prior information to direct
the choice of :ref:`emulator<DefEmulator>` structure and we combine
prior beliefs about the emulator parameters with model evaluations to
generate our emulator following the methods of the procedure on building
a Bayes linear emulator for the core problem
(:ref:`ProcBuildCoreBL<ProcBuildCoreBL>`). However, when the
:ref:`computer model<DefSimulator>` is relatively inexpensive to
evaluate and prior information is comparatively limited, then emulator
choice may be made on the basis of a very large collection of :ref:`simulator
evaluations<DefTrainingSample>`. In particular, this approach is
used for the emulation of a fast approximate version of the simulator
(see :ref:`multi-scale emulation<DefMultilevelEmulation>`).

In this situation, we may make many runs of the simulator, allowing us
to develop a preliminary view of the form of the function, and thereby
to make preliminary choices of the :ref:`basis
function<DefBasisFunctions>` collection :math:`\{h_j(x)\}`, and
suggest an informed prior specification for the random quantities that
determine the emulator for the simulator :math:`f(x)`. This analysis is
supported by a diagnostic analysis, for example based on looking for
systematic structure in the emulator residuals.

With such a large number of evaluations of the model, the emulator's
global trend can be identified and well-estimated from the data alone
without application of :ref:`Bayes<DefBayesian>`. For a Bayesian
treatment at this stage, our prior judgements would be dominated by the
large number of model evaluations so typically we use standard
model-fitting techniques.

As we are assuming that we have no substantial prior information about
the emulators, then we would typically consider evaluating the computer
model over a space-filling design over the input space to obtain good
coverage and to learn about global variation in :math:`f(x)`. We assume we
start this procedure with a large design (generated by methods such as
those discussed in the alternatives page on training sample design for
the core problem (:ref:`AltCoreDesign<AltCoreDesign>`)), and the
corresponding simulator evaluations at each of these input parameter
combinations.

Inputs
------

-  Design :math:`D` over the input space comprising the input points
   :math:`\{x_1,x_2,\dots,x_n\}`
-  Output vector :math:`f(D)=(f(x_1),f(x_2),\dots,f(x_n))^T`, where
   :math:`f(x_j)` is the simulator output corresponding to input vector
   :math:`x_j` in :math:`D`
-  A collection of potential basis functions, :math:`h(\cdot)`, for the
   prior mean function :math:`m(\cdot)`

Outputs
-------

-  A collection of appropriate basis functions for the emulator mean
   function
-  Expectation vector and variance/covariance matrix for regression
   coefficients :math:`\beta`
-  Adjusted residual process and specification of covariance function
   hyperparameters :math:`(\sigma^2,\delta)`

Procedure
---------

The general process for the empirical construction of an emulator
proceeds in the following four stages:

#. Determine the :ref:`active inputs<DefActiveInput>` to the emulator
#. Determine an appropriate subset of basis functions
#. Estimate emulator regression coefficients :math:`\beta`
#. Estimate residual process hyperparameters :math:`(\sigma^2,\delta)`

Determine active inputs
~~~~~~~~~~~~~~~~~~~~~~~

If we have chosen to work with :ref:`active inputs<DefActiveInput>`
in the means function, then the first step in constructing the emulator
is to identify the subset of inputs, :math:`x_A`, which drive the majority
of global variation in :math:`f(x)`. For this stage, we require a set of
possible basis functions (see the alternatives page on basis functions
for the emulator mean (:ref:`AltBasisFunctions<AltBasisFunctions>`)
for details.) Given this set of possible regressors and the ample supply
of computer evaluations, we can determine the important inputs and model
effects by methods such as stepwise fitting.

There are many possible approaches for empirically determining active
variables. The process of identifying active variable is known as
:ref:`screening<DefScreening>`. Typically, these methods take the
form of `model
selection <http://en.wikipedia.org/wiki/Model_selection>`_ and model
search problems. A simple such approach using backward `stepwise
regression <http://en.wikipedia.org/wiki/Stepwise_regression>`_ would
be:

#. Fit the emulator mean function using all possible basis functions -
   this is now the 'current' model
#. For each input in the current model, remove all terms involving that
   input variable and re-fit the mean function
#. Compare each of these sub-models with the current model using an
   appropriate criterion
#. The most favourable sub-model now becomes the current model
#. Iterate until an appropriate stopping criterion is satisfied

When the input space is very high-dimensional, a backward stepwise
approach may not be viable due to the large number of possible terms in
the initial mean function. In these cases, forward selection approaches
would be more appropriate beginning with a simple constant as the
initial mean function and adding terms in active variables at each stage
rather than removing them. Given a very large collection of potential
inputs, where possible, it is helpful to start the stepwise search with
a sub-collection of input suggested by expert knowledge of the physical
processes. Other approaches to :ref:`screening<DefScreening>` are
discussed in the topic thread on screening
(:ref:`ThreadTopicScreening<ThreadTopicScreening>`).

Determine regression basis functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The procedure for determining an appropriate collection of regression
basis functions is closely related to the problem of active input
identification. Again, this is a model selection problem where we now
have a reduced set of possible basis functions, all of which now only
involve the active inputs. We apply the same methods as above, only this
time removing or adding single regression terms in order to arrive at an
appropriate and parsimonious representation for the simulator output.

Estimate emulator regression coefficients
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The next stage is to quantify beliefs about the emulator coefficients
:math:`\beta`. We obtain values for these prior quantities by fitting the
mean function that we have determined in the previous stages to the
observed simulator runs to obtain estimates and associated uncertainty
statements about the coefficients :math:`\beta`.

There are a variety of ways in which we could fit the mean function to
obtain the estimates :math:`\hat{\beta}`. If we lack any insight into the
nature of the correlation structure of the residual process and our
design points are well-separated then we could fit the regression model
using `ordinary least
squares <http://en.wikipedia.org/wiki/Ordinary_Least_Squares>`__ (OLS).
Alternatively, if we have information about the correlation function and
its parameter values then more appropriate estimates could be obtained
by using this information and fitting by `generalised least
squares <http://en.wikipedia.org/wiki/Generalized_Least_Squares>`__
(GLS). We might use an iterative approach to estimate both the
regression coefficients and the correlation function hyperparameters.

The value of :math:`\textrm{E}[\beta]` is then taken to be the estimate
:math:`\hat{\beta}` from the fitting of the regression model and
:math:`\textrm{Var}[\beta]` is taken to be the variance of the
corresponding estimates. With sufficient evaluations in an approximately
orthogonal design, the estimation error here is negligible.

Estimate residual process hyperparameters
-----------------------------------------

The final stage is to make assessments for the values of the covariance
function hyperparameters :math:`(\sigma^2,\delta)` in our covariance
specifications for the residual process :math:`w(x)`.

Typically an estimate for :math:`\sigma^2` is obtained from fitting the
regression model in the form of the residual mean square
:math:`\hat{\sigma}^2`. Estimating correlation function hyperparameters for
the emulator residuals can be a more complex task, which is discussed in
the alternatives page on estimators of correlation hyperparameters
(:ref:`AltEstimateDelta<AltEstimateDelta>`). A common empirical
approach is :ref:`variogram fitting<ProcVariogram>`.

Validation and post-emulation tasks
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Given the emulator, we can perform similar diagnostics, validation, and
post-emulation tasks as described in the thread for Bayes linear
emulation for the core model (:ref:`ThreadCoreBL<ThreadCoreBL>`).

References
~~~~~~~~~~

Craig, P. S., Goldstein, M., Seheult, A. H., and Smith, J. A. (1998),
"Constructing partial prior specifications for models of complex
physical systems," *Applied Statistics*, 47, 37-53.
